@page "/Status"
@using DiffPlex
@using DiffPlex.DiffBuilder
@using DiffPlex.DiffBuilder.Model
@using HtmlAgilityPack;

@inject HttpClient HttpClient
@inject IJSRuntime JSRuntime

<PageTitle>Media Capture and Streams - Status</PageTitle>

@if (compareText is not null)
{
    <pre><code>
                @((MarkupString)compareText)
                </code></pre>
}
else
{
    <text>Loading WebIDL from specs ...</text>
    <br />
    <small>This make take a while as it is fetching the current specification live.</small>
}

@code {
    private string? compareText;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            string domString = await HttpClient.GetStringAsync("https://www.w3.org/TR/mediacapture-streams/");

            var dom = new HtmlDocument();
            dom.LoadHtml(domString);

            var webIdlHolders = dom.DocumentNode.Descendants()
                .Where(node => node.Id.StartsWith("webidl-"))
                .Select(webIdlHolder => webIdlHolder.ChildNodes.LastOrDefault())
                .Where(code => code is not null)
                .Cast<HtmlNode>()
                .Select(code => code.InnerText);
            var fetchedWedIdl = String.Join("\n\n", webIdlHolders).Replace("\n  ", "\n    ");
            var supportedWedIdl = currentlySupportedWebIDL.Replace("<", "&lt;").Replace(">", "&gt;");
            var compareLines = new List<string>();

            var diffBuilder = new InlineDiffBuilder(new Differ());
            var diffResult = diffBuilder.BuildDiffModel(fetchedWedIdl, supportedWedIdl);

            foreach (var line in diffResult.Lines)
            {
                string color = line.Type switch
                {
                    ChangeType.Unchanged => "lightgreen",
                    ChangeType.Deleted => "pink",
                    ChangeType.Inserted => "lemonchiffon",
                    _ => "pink"
                };
                compareLines.Add($"""<span style="background-color:{color};display:block;min-height:21px;">{line.Text}</span>""");
            }
            compareText = string.Join("", compareLines);
            StateHasChanged();
        }
    }

    private const string currentlySupportedWebIDL = @"[Exposed=Window]
interface MediaStream : EventTarget {
    constructor();
    constructor(MediaStream stream);
    constructor(sequence<MediaStreamTrack> tracks);
    readonly attribute DOMString id;
    sequence<MediaStreamTrack> getAudioTracks();
    sequence<MediaStreamTrack> getVideoTracks();
    sequence<MediaStreamTrack> getTracks();
    MediaStreamTrack? getTrackById(DOMString trackId);
    undefined addTrack(MediaStreamTrack track);
    undefined removeTrack(MediaStreamTrack track);
    MediaStream clone();
    readonly attribute boolean active;
    attribute EventHandler onaddtrack;
    attribute EventHandler onremovetrack;
};

[Exposed=Window]
interface MediaStreamTrack : EventTarget {
    readonly attribute DOMString kind;
    readonly attribute DOMString id;
    readonly attribute DOMString label;
    attribute boolean enabled;
    readonly attribute boolean muted;
    attribute EventHandler onmute;
    attribute EventHandler onunmute;
    readonly attribute MediaStreamTrackState readyState;
    attribute EventHandler onended;
    MediaStreamTrack clone();
    undefined stop();
    MediaTrackCapabilities getCapabilities();
    MediaTrackConstraints getConstraints();
    MediaTrackSettings getSettings();
    Promise<undefined> applyConstraints(optional MediaTrackConstraints constraints = {});
};

enum MediaStreamTrackState {
    ""live"",
    ""ended""
};

dictionary MediaTrackSupportedConstraints {
    boolean width = true;
    boolean height = true;
    boolean aspectRatio = true;
    boolean frameRate = true;
    boolean facingMode = true;
    boolean resizeMode = true;
    boolean sampleRate = true;
    boolean sampleSize = true;
    boolean echoCancellation = true;
    boolean autoGainControl = true;
    boolean noiseSuppression = true;
    boolean latency = true;
    boolean channelCount = true;
    boolean deviceId = true;
    boolean groupId = true;
};

dictionary MediaTrackCapabilities {
    ULongRange width;
    ULongRange height;
    DoubleRange aspectRatio;
    DoubleRange frameRate;
    sequence<DOMString> facingMode;
    sequence<DOMString> resizeMode;
    ULongRange sampleRate;
    ULongRange sampleSize;
    sequence<boolean> echoCancellation;
    sequence<boolean> autoGainControl;
    sequence<boolean> noiseSuppression;
    DoubleRange latency;
    ULongRange channelCount;
    DOMString deviceId;
    DOMString groupId;
};

dictionary MediaTrackConstraints : MediaTrackConstraintSet {
    sequence<MediaTrackConstraintSet> advanced;
};

dictionary MediaTrackConstraintSet {
    ConstrainULong width;
    ConstrainULong height;
    ConstrainDouble aspectRatio;
    ConstrainDouble frameRate;
    ConstrainDOMString facingMode;
    ConstrainDOMString resizeMode;
    ConstrainULong sampleRate;
    ConstrainULong sampleSize;
    ConstrainBoolean echoCancellation;
    ConstrainBoolean autoGainControl;
    ConstrainBoolean noiseSuppression;
    ConstrainDouble latency;
    ConstrainULong channelCount;
    ConstrainDOMString deviceId;
    ConstrainDOMString groupId;
};

dictionary MediaTrackSettings {
    unsigned long width;
    unsigned long height;
    double aspectRatio;
    double frameRate;
    DOMString facingMode;
    DOMString resizeMode;
    unsigned long sampleRate;
    unsigned long sampleSize;
    boolean echoCancellation;
    boolean autoGainControl;
    boolean noiseSuppression;
    double latency;
    unsigned long channelCount;
    DOMString deviceId;
    DOMString groupId;
};

enum VideoFacingModeEnum {
    ""user"",
    ""environment"",
    ""left"",
    ""right""
};

enum VideoResizeModeEnum {
    ""none"",
    ""crop-and-scale""
};

[Exposed=Window]
interface MediaStreamTrackEvent : Event {
  constructor(DOMString type, MediaStreamTrackEventInit eventInitDict);
  [SameObject] readonly attribute MediaStreamTrack track;
};

dictionary MediaStreamTrackEventInit : EventInit {
  required MediaStreamTrack track;
};

[Exposed=Window]
interface OverconstrainedError : DOMException {
  constructor(DOMString constraint, optional DOMString message = """");
  readonly attribute DOMString constraint;
};

partial interface Navigator {
    [SameObject, SecureContext] readonly attribute MediaDevices mediaDevices;
};

[Exposed=Window, SecureContext]
interface MediaDevices : EventTarget {
    attribute EventHandler ondevicechange;
    Promise<sequence<MediaDeviceInfo>> enumerateDevices();
};

[Exposed=Window, SecureContext]
interface MediaDeviceInfo {
    readonly attribute DOMString deviceId;
    readonly attribute MediaDeviceKind kind;
    readonly attribute DOMString label;
    readonly attribute DOMString groupId;
    [Default] object toJSON();
};

enum MediaDeviceKind {
    ""audioinput"",
    ""audiooutput"",
    ""videoinput""
};

[Exposed=Window, SecureContext]
interface InputDeviceInfo : MediaDeviceInfo {
    MediaTrackCapabilities getCapabilities();
};

partial interface MediaDevices {
    MediaTrackSupportedConstraints getSupportedConstraints();
    Promise<MediaStream> getUserMedia(optional MediaStreamConstraints constraints = {});
};

dictionary MediaStreamConstraints {
    (boolean or MediaTrackConstraints) video = false;
    (boolean or MediaTrackConstraints) audio = false;
};

callback NavigatorUserMediaSuccessCallback = undefined (MediaStream stream);

callback NavigatorUserMediaErrorCallback = undefined (DOMException error);

dictionary DoubleRange {
    double max;
    double min;
};

dictionary ConstrainDoubleRange : DoubleRange {
    double exact;
    double ideal;
};

dictionary ULongRange {
    [Clamp] unsigned long max;
    [Clamp] unsigned long min;
};

dictionary ConstrainULongRange : ULongRange {
    [Clamp] unsigned long exact;
    [Clamp] unsigned long ideal;
};

dictionary ConstrainBooleanParameters {
    boolean exact;
    boolean ideal;
};

dictionary ConstrainDOMStringParameters {
    (DOMString or sequence<DOMString>) exact;
    (DOMString or sequence<DOMString>) ideal;
};

typedef ([Clamp] unsigned long or ConstrainULongRange) ConstrainULong;

typedef (double or ConstrainDoubleRange) ConstrainDouble;

typedef (boolean or ConstrainBooleanParameters) ConstrainBoolean;

typedef (DOMString or
         sequence<DOMString> or
         ConstrainDOMStringParameters) ConstrainDOMString;";

}